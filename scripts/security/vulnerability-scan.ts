#!/usr/bin/env tsx
/**
 * 취약점 스캔 스크립트
 * 상세한 보안 취약점 분석 및 수정 방법 제안
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';

const execAsync = promisify(exec);

interface VulnerabilityDetails {
  id: string;
  title: string;
  severity: 'low' | 'moderate' | 'high' | 'critical';
  package: string;
  version: string;
  description: string;
  recommendation: string;
  references: string[];
  cvss: number;
  cwe: string[];
}

interface ScanResult {
  vulnerabilities: VulnerabilityDetails[];
  summary: {
    total: number;
    critical: number;
    high: number;
    moderate: number;
    low: number;
  };
  packages: {
    total: number;
    vulnerable: number;
    scanned: number;
  };
}

/**
 * 상세 취약점 스캔 실행
 */
async function scanVulnerabilities(packagePath: string): Promise<ScanResult> {
  try {
    console.log(`🔍 ${packagePath} 취약점 스캔 중...`);
    
    const { stdout } = await execAsync('pnpm audit --json', {
      cwd: packagePath,
      timeout: 45000
    });

    const auditData = JSON.parse(stdout);
    const vulnerabilities: VulnerabilityDetails[] = [];

    // 취약점 데이터 파싱
    if (auditData.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
        const vuln = vulnData as any;
        
        vulnerabilities.push({
          id: vuln.id || `${packageName}-${Date.now()}`,
          title: vuln.title || 'Unknown vulnerability',
          severity: vuln.severity || 'moderate',
          package: packageName,
          version: vuln.version || 'unknown',
          description: vuln.overview || 'No description available',
          recommendation: vuln.recommendation || 'Update to latest version',
          references: vuln.references || [],
          cvss: vuln.cvss?.score || 0,
          cwe: vuln.cwe || []
        });
      }
    }

    const summary = {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length
    };

    return {
      vulnerabilities,
      summary,
      packages: {
        total: auditData.metadata?.totalDependencies || 0,
        vulnerable: summary.total,
        scanned: auditData.metadata?.totalDependencies || 0
      }
    };

  } catch (error) {
    console.error(`❌ ${packagePath} 스캔 중 오류:`, error);
    return {
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
      packages: { total: 0, vulnerable: 0, scanned: 0 }
    };
  }
}

/**
 * 취약점 세부 정보 출력
 */
function printVulnerabilityDetails(vulnerabilities: VulnerabilityDetails[]): void {
  if (vulnerabilities.length === 0) {
    console.log('✅ 취약점이 발견되지 않았습니다.');
    return;
  }

  console.log('\n🔍 취약점 세부 정보:');
  console.log('='.repeat(80));

  // 심각도별 정렬
  const sorted = vulnerabilities.sort((a, b) => {
    const severityOrder = { critical: 4, high: 3, moderate: 2, low: 1 };
    return severityOrder[b.severity] - severityOrder[a.severity];
  });

  sorted.forEach((vuln, index) => {
    const emoji = getSeverityEmoji(vuln.severity);
    console.log(`\n${index + 1}. ${emoji} ${vuln.title} (${vuln.severity.toUpperCase()})`);
    console.log(`   📦 패키지: ${vuln.package}@${vuln.version}`);
    console.log(`   🆔 ID: ${vuln.id}`);
    
    if (vuln.cvss > 0) {
      console.log(`   📊 CVSS 점수: ${vuln.cvss}/10`);
    }
    
    if (vuln.cwe.length > 0) {
      console.log(`   🔗 CWE: ${vuln.cwe.join(', ')}`);
    }
    
    console.log(`   📝 설명: ${vuln.description}`);
    console.log(`   💡 권장사항: ${vuln.recommendation}`);
    
    if (vuln.references.length > 0) {
      console.log(`   🔗 참고 링크:`);
      vuln.references.slice(0, 2).forEach(ref => {
        console.log(`      - ${ref}`);
      });
    }
  });
}

/**
 * 심각도 이모지 반환
 */
function getSeverityEmoji(severity: string): string {
  switch (severity) {
    case 'critical': return '🚨';
    case 'high': return '⚠️';
    case 'moderate': return '💡';
    case 'low': return 'ℹ️';
    default: return '❓';
  }
}

/**
 * 수정 가이드 생성
 */
function generateFixGuide(vulnerabilities: VulnerabilityDetails[]): string[] {
  const guides: string[] = [];
  
  // 패키지별 그룹화
  const packageGroups = vulnerabilities.reduce((groups, vuln) => {
    if (!groups[vuln.package]) {
      groups[vuln.package] = [];
    }
    groups[vuln.package].push(vuln);
    return groups;
  }, {} as Record<string, VulnerabilityDetails[]>);

  Object.entries(packageGroups).forEach(([packageName, vulns]) => {
    const highestSeverity = vulns.sort((a, b) => {
      const severityOrder = { critical: 4, high: 3, moderate: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    })[0];

    guides.push(`📦 ${packageName}:`);
    guides.push(`   🔧 pnpm update ${packageName}`);
    guides.push(`   📋 ${vulns.length}개의 취약점 (최고 심각도: ${highestSeverity.severity})`);
    guides.push('');
  });

  return guides;
}

/**
 * 스캔 리포트 생성
 */
function generateScanReport(allResults: ScanResult[], packageNames: string[]): void {
  const reportPath = path.join(process.cwd(), 'vulnerability-scan-report.json');
  
  const combinedResult = allResults.reduce((combined, result) => {
    combined.vulnerabilities.push(...result.vulnerabilities);
    combined.summary.total += result.summary.total;
    combined.summary.critical += result.summary.critical;
    combined.summary.high += result.summary.high;
    combined.summary.moderate += result.summary.moderate;
    combined.summary.low += result.summary.low;
    combined.packages.total += result.packages.total;
    combined.packages.vulnerable += result.packages.vulnerable;
    combined.packages.scanned += result.packages.scanned;
    return combined;
  }, {
    vulnerabilities: [] as VulnerabilityDetails[],
    summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    packages: { total: 0, vulnerable: 0, scanned: 0 }
  });

  const report = {
    timestamp: new Date().toISOString(),
    scanResults: combinedResult,
    packageResults: allResults.map((result, index) => ({
      package: packageNames[index],
      ...result
    })),
    fixGuide: generateFixGuide(combinedResult.vulnerabilities),
    riskScore: calculateRiskScore(combinedResult.summary),
    recommendations: generateRecommendations(combinedResult.summary)
  };

  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`\n📄 스캔 리포트 생성: ${reportPath}`);
}

/**
 * 위험도 점수 계산
 */
function calculateRiskScore(summary: ScanResult['summary']): number {
  const weights = { critical: 10, high: 7, moderate: 4, low: 1 };
  const score = (
    summary.critical * weights.critical +
    summary.high * weights.high +
    summary.moderate * weights.moderate +
    summary.low * weights.low
  );
  
  return Math.min(score, 100);
}

/**
 * 권장사항 생성
 */
function generateRecommendations(summary: ScanResult['summary']): string[] {
  const recommendations: string[] = [];
  
  if (summary.critical > 0) {
    recommendations.push('🚨 즉시 조치 필요: 치명적 취약점이 발견되었습니다.');
    recommendations.push('   - 모든 배포를 중단하고 즉시 업데이트하세요.');
  }
  
  if (summary.high > 0) {
    recommendations.push('⚠️ 높은 우선순위: 높은 수준의 취약점이 발견되었습니다.');
    recommendations.push('   - 24시간 내에 업데이트를 완료하세요.');
  }
  
  if (summary.moderate > 0) {
    recommendations.push('💡 중간 우선순위: 보통 수준의 취약점이 발견되었습니다.');
    recommendations.push('   - 다음 정기 업데이트 시 포함하세요.');
  }
  
  if (summary.low > 0) {
    recommendations.push('ℹ️ 낮은 우선순위: 낮은 수준의 취약점이 발견되었습니다.');
    recommendations.push('   - 편한 시간에 업데이트하세요.');
  }
  
  recommendations.push('');
  recommendations.push('🔧 자동 수정 명령어:');
  recommendations.push('   - npm run security:update');
  recommendations.push('   - pnpm audit --fix');
  
  return recommendations;
}

/**
 * 메인 실행 함수
 */
async function main(): Promise<void> {
  try {
    console.log('🔍 TFT Meta Analyzer 취약점 스캔 시작');
    console.log('='.repeat(50));
    
    const packages = [
      { path: '.', name: 'Root' },
      { path: 'backend', name: 'Backend' },
      { path: 'frontend', name: 'Frontend' },
      { path: 'shared', name: 'Shared' }
    ];
    
    const allResults: ScanResult[] = [];
    const packageNames: string[] = [];
    
    for (const pkg of packages) {
      const packagePath = path.join(process.cwd(), pkg.path);
      if (fs.existsSync(path.join(packagePath, 'package.json'))) {
        const result = await scanVulnerabilities(packagePath);
        allResults.push(result);
        packageNames.push(pkg.name);
        
        console.log(`\n📊 ${pkg.name} 스캔 결과:`);
        console.log(`   🔍 스캔된 패키지: ${result.packages.scanned}`);
        console.log(`   ⚠️ 취약점 총 개수: ${result.summary.total}`);
        
        if (result.summary.total > 0) {
          console.log(`   🚨 치명적: ${result.summary.critical}`);
          console.log(`   ⚠️ 높음: ${result.summary.high}`);
          console.log(`   💡 보통: ${result.summary.moderate}`);
          console.log(`   ℹ️ 낮음: ${result.summary.low}`);
        }
      }
    }
    
    // 전체 결과 통합
    const totalVulnerabilities = allResults.reduce((total, result) => {
      return total.concat(result.vulnerabilities);
    }, [] as VulnerabilityDetails[]);
    
    printVulnerabilityDetails(totalVulnerabilities);
    generateScanReport(allResults, packageNames);
    
    console.log('\n✅ 취약점 스캔 완료');
    
    // 치명적 취약점이 있으면 프로세스 종료 코드 1로 종료
    const hasCritical = allResults.some(result => result.summary.critical > 0);
    if (hasCritical) {
      console.log('\n🚨 치명적 취약점으로 인해 프로세스를 종료합니다.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('❌ 취약점 스캔 중 오류:', error);
    process.exit(1);
  }
}

// 스크립트 실행
if (require.main === module) {
  main();
}

export { scanVulnerabilities, generateScanReport, calculateRiskScore };