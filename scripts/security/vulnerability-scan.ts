#!/usr/bin/env tsx
/**
 * ì·¨ì•½ì  ìŠ¤ìº” ìŠ¤í¬ë¦½íŠ¸
 * ìƒì„¸í•œ ë³´ì•ˆ ì·¨ì•½ì  ë¶„ì„ ë° ìˆ˜ì • ë°©ë²• ì œì•ˆ
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';

const execAsync = promisify(exec);

interface VulnerabilityDetails {
  id: string;
  title: string;
  severity: 'low' | 'moderate' | 'high' | 'critical';
  package: string;
  version: string;
  description: string;
  recommendation: string;
  references: string[];
  cvss: number;
  cwe: string[];
}

interface ScanResult {
  vulnerabilities: VulnerabilityDetails[];
  summary: {
    total: number;
    critical: number;
    high: number;
    moderate: number;
    low: number;
  };
  packages: {
    total: number;
    vulnerable: number;
    scanned: number;
  };
}

/**
 * ìƒì„¸ ì·¨ì•½ì  ìŠ¤ìº” ì‹¤í–‰
 */
async function scanVulnerabilities(packagePath: string): Promise<ScanResult> {
  try {
    console.log(`ğŸ” ${packagePath} ì·¨ì•½ì  ìŠ¤ìº” ì¤‘...`);
    
    const { stdout } = await execAsync('pnpm audit --json', {
      cwd: packagePath,
      timeout: 45000
    });

    const auditData = JSON.parse(stdout);
    const vulnerabilities: VulnerabilityDetails[] = [];

    // ì·¨ì•½ì  ë°ì´í„° íŒŒì‹±
    if (auditData.vulnerabilities) {
      for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
        const vuln = vulnData as any;
        
        vulnerabilities.push({
          id: vuln.id || `${packageName}-${Date.now()}`,
          title: vuln.title || 'Unknown vulnerability',
          severity: vuln.severity || 'moderate',
          package: packageName,
          version: vuln.version || 'unknown',
          description: vuln.overview || 'No description available',
          recommendation: vuln.recommendation || 'Update to latest version',
          references: vuln.references || [],
          cvss: vuln.cvss?.score || 0,
          cwe: vuln.cwe || []
        });
      }
    }

    const summary = {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length
    };

    return {
      vulnerabilities,
      summary,
      packages: {
        total: auditData.metadata?.totalDependencies || 0,
        vulnerable: summary.total,
        scanned: auditData.metadata?.totalDependencies || 0
      }
    };

  } catch (error) {
    console.error(`âŒ ${packagePath} ìŠ¤ìº” ì¤‘ ì˜¤ë¥˜:`, error);
    return {
      vulnerabilities: [],
      summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
      packages: { total: 0, vulnerable: 0, scanned: 0 }
    };
  }
}

/**
 * ì·¨ì•½ì  ì„¸ë¶€ ì •ë³´ ì¶œë ¥
 */
function printVulnerabilityDetails(vulnerabilities: VulnerabilityDetails[]): void {
  if (vulnerabilities.length === 0) {
    console.log('âœ… ì·¨ì•½ì ì´ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    return;
  }

  console.log('\nğŸ” ì·¨ì•½ì  ì„¸ë¶€ ì •ë³´:');
  console.log('='.repeat(80));

  // ì‹¬ê°ë„ë³„ ì •ë ¬
  const sorted = vulnerabilities.sort((a, b) => {
    const severityOrder = { critical: 4, high: 3, moderate: 2, low: 1 };
    return severityOrder[b.severity] - severityOrder[a.severity];
  });

  sorted.forEach((vuln, index) => {
    const emoji = getSeverityEmoji(vuln.severity);
    console.log(`\n${index + 1}. ${emoji} ${vuln.title} (${vuln.severity.toUpperCase()})`);
    console.log(`   ğŸ“¦ íŒ¨í‚¤ì§€: ${vuln.package}@${vuln.version}`);
    console.log(`   ğŸ†” ID: ${vuln.id}`);
    
    if (vuln.cvss > 0) {
      console.log(`   ğŸ“Š CVSS ì ìˆ˜: ${vuln.cvss}/10`);
    }
    
    if (vuln.cwe.length > 0) {
      console.log(`   ğŸ”— CWE: ${vuln.cwe.join(', ')}`);
    }
    
    console.log(`   ğŸ“ ì„¤ëª…: ${vuln.description}`);
    console.log(`   ğŸ’¡ ê¶Œì¥ì‚¬í•­: ${vuln.recommendation}`);
    
    if (vuln.references.length > 0) {
      console.log(`   ğŸ”— ì°¸ê³  ë§í¬:`);
      vuln.references.slice(0, 2).forEach(ref => {
        console.log(`      - ${ref}`);
      });
    }
  });
}

/**
 * ì‹¬ê°ë„ ì´ëª¨ì§€ ë°˜í™˜
 */
function getSeverityEmoji(severity: string): string {
  switch (severity) {
    case 'critical': return 'ğŸš¨';
    case 'high': return 'âš ï¸';
    case 'moderate': return 'ğŸ’¡';
    case 'low': return 'â„¹ï¸';
    default: return 'â“';
  }
}

/**
 * ìˆ˜ì • ê°€ì´ë“œ ìƒì„±
 */
function generateFixGuide(vulnerabilities: VulnerabilityDetails[]): string[] {
  const guides: string[] = [];
  
  // íŒ¨í‚¤ì§€ë³„ ê·¸ë£¹í™”
  const packageGroups = vulnerabilities.reduce((groups, vuln) => {
    if (!groups[vuln.package]) {
      groups[vuln.package] = [];
    }
    groups[vuln.package].push(vuln);
    return groups;
  }, {} as Record<string, VulnerabilityDetails[]>);

  Object.entries(packageGroups).forEach(([packageName, vulns]) => {
    const highestSeverity = vulns.sort((a, b) => {
      const severityOrder = { critical: 4, high: 3, moderate: 2, low: 1 };
      return severityOrder[b.severity] - severityOrder[a.severity];
    })[0];

    guides.push(`ğŸ“¦ ${packageName}:`);
    guides.push(`   ğŸ”§ pnpm update ${packageName}`);
    guides.push(`   ğŸ“‹ ${vulns.length}ê°œì˜ ì·¨ì•½ì  (ìµœê³  ì‹¬ê°ë„: ${highestSeverity.severity})`);
    guides.push('');
  });

  return guides;
}

/**
 * ìŠ¤ìº” ë¦¬í¬íŠ¸ ìƒì„±
 */
function generateScanReport(allResults: ScanResult[], packageNames: string[]): void {
  const reportPath = path.join(process.cwd(), 'vulnerability-scan-report.json');
  
  const combinedResult = allResults.reduce((combined, result) => {
    combined.vulnerabilities.push(...result.vulnerabilities);
    combined.summary.total += result.summary.total;
    combined.summary.critical += result.summary.critical;
    combined.summary.high += result.summary.high;
    combined.summary.moderate += result.summary.moderate;
    combined.summary.low += result.summary.low;
    combined.packages.total += result.packages.total;
    combined.packages.vulnerable += result.packages.vulnerable;
    combined.packages.scanned += result.packages.scanned;
    return combined;
  }, {
    vulnerabilities: [] as VulnerabilityDetails[],
    summary: { total: 0, critical: 0, high: 0, moderate: 0, low: 0 },
    packages: { total: 0, vulnerable: 0, scanned: 0 }
  });

  const report = {
    timestamp: new Date().toISOString(),
    scanResults: combinedResult,
    packageResults: allResults.map((result, index) => ({
      package: packageNames[index],
      ...result
    })),
    fixGuide: generateFixGuide(combinedResult.vulnerabilities),
    riskScore: calculateRiskScore(combinedResult.summary),
    recommendations: generateRecommendations(combinedResult.summary)
  };

  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`\nğŸ“„ ìŠ¤ìº” ë¦¬í¬íŠ¸ ìƒì„±: ${reportPath}`);
}

/**
 * ìœ„í—˜ë„ ì ìˆ˜ ê³„ì‚°
 */
function calculateRiskScore(summary: ScanResult['summary']): number {
  const weights = { critical: 10, high: 7, moderate: 4, low: 1 };
  const score = (
    summary.critical * weights.critical +
    summary.high * weights.high +
    summary.moderate * weights.moderate +
    summary.low * weights.low
  );
  
  return Math.min(score, 100);
}

/**
 * ê¶Œì¥ì‚¬í•­ ìƒì„±
 */
function generateRecommendations(summary: ScanResult['summary']): string[] {
  const recommendations: string[] = [];
  
  if (summary.critical > 0) {
    recommendations.push('ğŸš¨ ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš”: ì¹˜ëª…ì  ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    recommendations.push('   - ëª¨ë“  ë°°í¬ë¥¼ ì¤‘ë‹¨í•˜ê³  ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.');
  }
  
  if (summary.high > 0) {
    recommendations.push('âš ï¸ ë†’ì€ ìš°ì„ ìˆœìœ„: ë†’ì€ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    recommendations.push('   - 24ì‹œê°„ ë‚´ì— ì—…ë°ì´íŠ¸ë¥¼ ì™„ë£Œí•˜ì„¸ìš”.');
  }
  
  if (summary.moderate > 0) {
    recommendations.push('ğŸ’¡ ì¤‘ê°„ ìš°ì„ ìˆœìœ„: ë³´í†µ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    recommendations.push('   - ë‹¤ìŒ ì •ê¸° ì—…ë°ì´íŠ¸ ì‹œ í¬í•¨í•˜ì„¸ìš”.');
  }
  
  if (summary.low > 0) {
    recommendations.push('â„¹ï¸ ë‚®ì€ ìš°ì„ ìˆœìœ„: ë‚®ì€ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
    recommendations.push('   - í¸í•œ ì‹œê°„ì— ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.');
  }
  
  recommendations.push('');
  recommendations.push('ğŸ”§ ìë™ ìˆ˜ì • ëª…ë ¹ì–´:');
  recommendations.push('   - npm run security:update');
  recommendations.push('   - pnpm audit --fix');
  
  return recommendations;
}

/**
 * ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
 */
async function main(): Promise<void> {
  try {
    console.log('ğŸ” TFT Meta Analyzer ì·¨ì•½ì  ìŠ¤ìº” ì‹œì‘');
    console.log('='.repeat(50));
    
    const packages = [
      { path: '.', name: 'Root' },
      { path: 'backend', name: 'Backend' },
      { path: 'frontend', name: 'Frontend' },
      { path: 'shared', name: 'Shared' }
    ];
    
    const allResults: ScanResult[] = [];
    const packageNames: string[] = [];
    
    for (const pkg of packages) {
      const packagePath = path.join(process.cwd(), pkg.path);
      if (fs.existsSync(path.join(packagePath, 'package.json'))) {
        const result = await scanVulnerabilities(packagePath);
        allResults.push(result);
        packageNames.push(pkg.name);
        
        console.log(`\nğŸ“Š ${pkg.name} ìŠ¤ìº” ê²°ê³¼:`);
        console.log(`   ğŸ” ìŠ¤ìº”ëœ íŒ¨í‚¤ì§€: ${result.packages.scanned}`);
        console.log(`   âš ï¸ ì·¨ì•½ì  ì´ ê°œìˆ˜: ${result.summary.total}`);
        
        if (result.summary.total > 0) {
          console.log(`   ğŸš¨ ì¹˜ëª…ì : ${result.summary.critical}`);
          console.log(`   âš ï¸ ë†’ìŒ: ${result.summary.high}`);
          console.log(`   ğŸ’¡ ë³´í†µ: ${result.summary.moderate}`);
          console.log(`   â„¹ï¸ ë‚®ìŒ: ${result.summary.low}`);
        }
      }
    }
    
    // ì „ì²´ ê²°ê³¼ í†µí•©
    const totalVulnerabilities = allResults.reduce((total, result) => {
      return total.concat(result.vulnerabilities);
    }, [] as VulnerabilityDetails[]);
    
    printVulnerabilityDetails(totalVulnerabilities);
    generateScanReport(allResults, packageNames);
    
    console.log('\nâœ… ì·¨ì•½ì  ìŠ¤ìº” ì™„ë£Œ');
    
    // ì¹˜ëª…ì  ì·¨ì•½ì ì´ ìˆìœ¼ë©´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ì½”ë“œ 1ë¡œ ì¢…ë£Œ
    const hasCritical = allResults.some(result => result.summary.critical > 0);
    if (hasCritical) {
      console.log('\nğŸš¨ ì¹˜ëª…ì  ì·¨ì•½ì ìœ¼ë¡œ ì¸í•´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('âŒ ì·¨ì•½ì  ìŠ¤ìº” ì¤‘ ì˜¤ë¥˜:', error);
    process.exit(1);
  }
}

// ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
if (require.main === module) {
  main();
}

export { scanVulnerabilities, generateScanReport, calculateRiskScore };