import React, { createContext, useState, useEffect, useContext, useMemo, useCallback } from 'react';
import { api } from '../utils/fetchApi';

const TFTDataContext = createContext();

export const useTFTData = () => useContext(TFTDataContext);

export const TFTDataProvider = ({ children }) => {
  const [itemsByCategory, setItemsByCategory] = useState({});
  const [tftData, setTftData] = useState({
    champions: [],
    items: { basic: [], completed: [], ornn: [], radiant: [], emblem: [], support: [], robot: [], unknown: [] },
    augments: [],
    traits: [],
    traitMap: new Map(),
    krNameMap: new Map(),
    currentSet: '',
  });

  const allItems = useMemo(() => {
    if (!itemsByCategory) return [];
    return Object.values(itemsByCategory).flat();
  }, [itemsByCategory]);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [tooltip, setTooltip] = useState({
    visible: false,
    data: null,
    position: { x: 0, y: 0 },
  });

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      try {
        const [tftMetaResponse, itemsByCategoryResponse] = await Promise.all([
          api.get(`/api/static-data/tft-data`),
          api.get(`/api/static-data/items-by-category`)
        ]);

        const receivedTftData = tftMetaResponse;

        // ðŸ’¡ í•µì‹¬ ìˆ˜ì •: ë°±ì—”ë“œì—ì„œ [key, value] ë°°ì—´ë¡œ ë°›ì€ traitMapê³¼ krNameMapì„ ë‹¤ì‹œ Map ê°ì²´ë¡œ ìž¬êµ¬ì„±í•©ë‹ˆë‹¤.
        const rehydratedTraitMap = new Map(receivedTftData.traitMap);
        const rehydratedKrNameMap = new Map(receivedTftData.krNameMap);

        // ðŸ’¡ í•µì‹¬ ìˆ˜ì •: traitMapì˜ [key, value]ë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ì—¬ ê° trait ê°ì²´ì— apiNameì„ ì£¼ìž…í•©ë‹ˆë‹¤.
        const extractedTraits = Array.from(rehydratedTraitMap.entries()).map(([apiName, traitData]) => ({
          ...traitData,
          apiName: apiName, 
        }));

        setTftData({
          ...receivedTftData,
          traits: extractedTraits, // ì¶”ì¶œëœ traits ë°°ì—´ì„ ì¶”ê°€
          traitMap: rehydratedTraitMap, // ìž¬êµ¬ì„±ëœ Map ê°ì²´ í• ë‹¹
          krNameMap: rehydratedKrNameMap, // ìž¬êµ¬ì„±ëœ Map ê°ì²´ í• ë‹¹
        });
        setItemsByCategory(itemsByCategoryResponse);

      } catch (error) {
        // TFT ë°ì´í„° ë¡œë”© ì‹¤íŒ¨
        setError(error.message || "ë°ì´í„° ë¡œë”© ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ ë°œìƒ");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const showTooltip = useCallback((data, event) => {
    const tooltipWidth = 320; // íˆ´íŒì˜ ê°€ë¡œ ë„ˆë¹„ (w-80)
    const x = event.clientX + 15 + tooltipWidth > window.innerWidth
      ? event.clientX - tooltipWidth - 15
      : event.clientX + 15;
    const y = event.clientY + 15;

    setTooltip({
      visible: true,
      data: data,
      position: { x, y }
    });
  }, []);

  const hideTooltip = useCallback(() => {
    setTooltip(prev => ({ ...prev, visible: false }));
  }, []);

  const value = useMemo(() => ({
    ...tftData,
    itemsByCategory,
    allItems,
    loading,
    error,
    tooltip,
    showTooltip,
    hideTooltip,
  }), [tftData, itemsByCategory, allItems, loading, error, tooltip, showTooltip, hideTooltip]);

  return (
    <TFTDataContext.Provider value={value}>
      {children}
    </TFTDataContext.Provider>
  );
};