// backend/src/middlewares/telemetryMiddleware.ts - TFT í…”ë ˆë©”íŠ¸ë¦¬ ë¯¸ë“¤ì›¨ì–´
import { Request, Response, NextFunction } from 'express';
import { trace, context, SpanStatusCode } from '@opentelemetry/api';
import {
  recordApiResponseTime,
  recordUserRequest,
  recordError,
  concurrentUsersGauge,
} from '../services/telemetry/tftMetrics';
import logger from '../config/logger';

// í™œì„± ì‚¬ìš©ì ì¶”ì 
const activeUsers = new Set<string>();

/**
 * TFT íŠ¹í™” í…”ë ˆë©”íŠ¸ë¦¬ ë¯¸ë“¤ì›¨ì–´
 */
export function tftTelemetryMiddleware(req: Request, res: Response, next: NextFunction): void {
  const startTime = Date.now();
  const tracer = trace.getTracer('tft-meta-analyzer');
  
  // ìŠ¤íŒ¬ ìƒì„±
  const span = tracer.startSpan(`${req.method} ${req.route?.path || req.path}`, {
    attributes: {
      'http.method': req.method,
      'http.url': req.url,
      'http.route': req.route?.path || req.path,
      'tft.endpoint.category': getTFTEndpointCategory(req.path),
      'tft.user.region': extractUserRegion(req),
      'tft.user.tier': extractUserTier(req),
      'tft.request.size': req.headers['content-length'] || '0',
    },
  });

  // í™œì„± ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
  context.with(trace.setSpan(context.active(), span), () => {
    // ì‚¬ìš©ì ì¶”ì 
    const userId = extractUserId(req);
    if (userId) {
      activeUsers.add(userId);
      concurrentUsersGauge.add(1, {
        endpoint_category: getTFTEndpointCategory(req.path),
      });
    }

    // ì‚¬ìš©ì ìš”ì²­ ë©”íŠ¸ë¦­ ê¸°ë¡
    recordUserRequest(
      req.path,
      extractUserRegion(req),
      extractUserTier(req)
    );

    // ì‘ë‹µ ì™„ë£Œ ì‹œ ì²˜ë¦¬
    res.on('finish', () => {
      const duration = Date.now() - startTime;
      
      // API ì‘ë‹µ ì‹œê°„ ë©”íŠ¸ë¦­ ê¸°ë¡
      recordApiResponseTime(
        req.path,
        req.method,
        res.statusCode,
        duration
      );

      // ìŠ¤íŒ¬ ì†ì„± ì—…ë°ì´íŠ¸
      span.setAttributes({
        'http.status_code': res.statusCode,
        'tft.response.size': res.getHeader('content-length') || '0',
        'tft.response.time': duration,
        'tft.cache.hit': res.getHeader('x-cache-hit') === 'true',
        'tft.cache.layer': res.getHeader('x-cache-layer') || 'none',
      });

      // ì—ëŸ¬ ìƒíƒœ ì²˜ë¦¬
      if (res.statusCode >= 400) {
        span.recordException(new Error(`HTTP ${res.statusCode}: ${res.statusMessage}`));
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: `HTTP ${res.statusCode}`,
        });

        // ì—ëŸ¬ ë©”íŠ¸ë¦­ ê¸°ë¡
        recordError(
          getErrorType(res.statusCode),
          req.path,
          res.statusCode
        );
      } else {
        span.setStatus({ code: SpanStatusCode.OK });
      }

      // ì‚¬ìš©ì ì„¸ì…˜ ì •ë¦¬
      if (userId) {
        activeUsers.delete(userId);
        concurrentUsersGauge.add(-1, {
          endpoint_category: getTFTEndpointCategory(req.path),
        });
      }

      // ìŠ¤íŒ¬ ì¢…ë£Œ
      span.end();
    });

    // ìš”ì²­ ì·¨ì†Œ ì‹œ ì²˜ë¦¬
    req.on('close', () => {
      if (!res.finished) {
        span.recordException(new Error('Request cancelled'));
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: 'Request cancelled',
        });
        span.end();
      }
    });

    next();
  });
}

/**
 * ìºì‹œ íˆíŠ¸ ì •ë³´ë¥¼ ì‘ë‹µ í—¤ë”ì— ì¶”ê°€í•˜ëŠ” ë¯¸ë“¤ì›¨ì–´
 */
export function cacheHeaderMiddleware(req: Request, res: Response, next: NextFunction): void {
  const originalSend = res.send;
  
  res.send = function(data: any) {
    // ìºì‹œ ì •ë³´ê°€ ìˆë‹¤ë©´ í—¤ë”ì— ì¶”ê°€
    if (res.locals.cacheHit !== undefined) {
      res.setHeader('X-Cache-Hit', res.locals.cacheHit.toString());
    }
    
    if (res.locals.cacheLayer) {
      res.setHeader('X-Cache-Layer', res.locals.cacheLayer);
    }
    
    return originalSend.call(this, data);
  };
  
  next();
}

/**
 * ì™¸ë¶€ API í˜¸ì¶œ ì¶”ì ì„ ìœ„í•œ ë¯¸ë“¤ì›¨ì–´
 */
export function externalApiTrackingMiddleware(req: Request, res: Response, next: NextFunction): void {
  const tracer = trace.getTracer('tft-meta-analyzer');
  
  // Riot API í˜¸ì¶œ ì¶”ì 
  if (req.url.includes('riot')) {
    const span = tracer.startSpan('riot_api_call', {
      attributes: {
        'tft.api.type': 'riot',
        'tft.api.region': extractRegionFromRequest(req),
        'tft.api.endpoint': req.path,
      },
    });
    
    res.locals.externalApiSpan = span;
  }
  
  // Google AI API í˜¸ì¶œ ì¶”ì 
  if (req.url.includes('ai')) {
    const span = tracer.startSpan('google_ai_call', {
      attributes: {
        'tft.api.type': 'google_ai',
        'tft.ai.analysis_type': extractAnalysisType(req),
      },
    });
    
    res.locals.externalApiSpan = span;
  }
  
  next();
}

// === í—¬í¼ í•¨ìˆ˜ë“¤ ===

function getTFTEndpointCategory(path: string): string {
  if (path.includes('/summoner')) return 'summoner';
  if (path.includes('/ai')) return 'ai_analysis';
  if (path.includes('/match')) return 'match_data';
  if (path.includes('/tierlist')) return 'tierlist';
  if (path.includes('/ranking')) return 'ranking';
  if (path.includes('/static-data')) return 'static_data';
  if (path.includes('/cache')) return 'cache_management';
  if (path.includes('/health')) return 'health_check';
  return 'other';
}

function extractUserRegion(req: Request): string {
  return req.query.region as string || 
         req.params.region as string || 
         req.headers['x-user-region'] as string || 
         'kr';
}

function extractUserTier(req: Request): string | undefined {
  return req.query.tier as string || 
         req.headers['x-user-tier'] as string || 
         undefined;
}

function extractUserId(req: Request): string | undefined {
  return req.headers['x-user-id'] as string ||
         req.query.puuid as string ||
         req.params.puuid as string ||
         undefined;
}

function extractRegionFromRequest(req: Request): string {
  return req.params.region || req.query.region as string || 'kr';
}

function extractAnalysisType(req: Request): string {
  if (req.path.includes('/analyze')) return 'match';
  if (req.path.includes('/meta')) return 'meta';
  if (req.path.includes('/deck')) return 'deck';
  return 'unknown';
}

function getErrorType(statusCode: number): string {
  if (statusCode >= 400 && statusCode < 500) {
    switch (statusCode) {
      case 400: return 'bad_request';
      case 401: return 'unauthorized';
      case 403: return 'forbidden';
      case 404: return 'not_found';
      case 429: return 'rate_limit';
      default: return 'client_error';
    }
  }
  
  if (statusCode >= 500) {
    switch (statusCode) {
      case 500: return 'internal_server_error';
      case 502: return 'bad_gateway';
      case 503: return 'service_unavailable';
      case 504: return 'gateway_timeout';
      default: return 'server_error';
    }
  }
  
  return 'unknown';
}

/**
 * ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­ ì¶”ì ì„ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ë“¤
 */
export function trackMatchAnalysis(matchId: string, region: string, tier: string): void {
  const tracer = trace.getTracer('tft-meta-analyzer');
  
  tracer.startSpan('match_analysis', {
    attributes: {
      'tft.match.id': matchId,
      'tft.match.region': region,
      'tft.match.tier': tier,
    },
  }).end();
}

export function trackAiAnalysis(analysisType: string, duration: number, success: boolean): void {
  const tracer = trace.getTracer('tft-meta-analyzer');
  
  tracer.startSpan('ai_analysis', {
    attributes: {
      'tft.ai.analysis_type': analysisType,
      'tft.ai.duration': duration,
      'tft.ai.success': success,
    },
  }).end();
}

export function trackCacheOperation(operation: 'get' | 'set' | 'del', layer: 'L1' | 'L2', key: string, hit: boolean): void {
  const tracer = trace.getTracer('tft-meta-analyzer');
  
  tracer.startSpan(`cache_${operation}`, {
    attributes: {
      'tft.cache.layer': layer,
      'tft.cache.key': key,
      'tft.cache.hit': hit,
      'tft.cache.key_type': getCacheKeyType(key),
    },
  }).end();
}

function getCacheKeyType(key: string): string {
  if (key.includes('summoner')) return 'summoner_data';
  if (key.includes('match')) return 'match_data';
  if (key.includes('ai_analysis')) return 'ai_analysis';
  if (key.includes('tierlist')) return 'tierlist';
  if (key.includes('meta')) return 'meta_data';
  if (key.includes('translation')) return 'translation';
  if (key.includes('tft_data')) return 'tft_static_data';
  return 'other';
}

logger.info('ğŸ” TFT í…”ë ˆë©”íŠ¸ë¦¬ ë¯¸ë“¤ì›¨ì–´ ì´ˆê¸°í™” ì™„ë£Œ');